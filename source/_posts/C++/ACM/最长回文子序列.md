---
title: 最长回文子序列
tags:
- 搜索
- 字符串
category:
- C++
- ACM
---

## DP - O(n^2)

```c++
         for (int k = 1; k < n; k++)
	    	{
			for (int i = 0; i+k < n; i++)
			{
				dp[i][i + k] = max(dp[i][i + k - 1], dp[i + 1][i + k]);
				if (a[i] == a[i + k])
				{
					dp[i][i + k] = max(dp[i][i + k], dp[i + 1][i + k - 1] + 1);
				}
			}
		}

```

## Manacher O(n)

先在原串`str`每个字符左右加一个`#`，转化为奇数长度，新的字符串命名为`m`串

`abba ->  #a#b#b#a#` ,长度为9

最后记得把长度除以二

首先,在字符串`m`中,用`p[i]`表示`m`串第`i`个字符的回文半径,即`p[i]`尽可能大,且满足:

```s[i-p[i], i-1]=s[i+1, i+p[i]]```

可~~观察出~~证明`p[i]-1`即为`str`的回文串长度。

然后，从左往右遍历。执行完一步

`p[i] = mx > i ? min(p[2 * id - i], mx - i) : 1;`

以后，要把`p[i]`向两边扩展。嗯这个for套while不就O(N^2)了吗？？？？

其实并没有。我们看一下每个字符被访问了几次。

首先遍历的时候就有一次。主要是看while()语句中被访问了几次。
执行完

`p[i] = mx > i ? min(p[2 * id - i], mx - i) : 1;`

以后，如果是下图这种情况，就不需要扩展（`p[i]++`）；

![123](https://image-static.segmentfault.com/406/055/4060550705-58b9671c71085)

只有下图的这种情况，才会进行扩展，此时i右边的字符被访问了两次。但是扩展以后，相应的`Mx`也会变大，使得下次就扩展不会考虑到这个点。所以每个字符只会被访问两次。证毕。

![123](https://image-static.segmentfault.com/282/937/282937517-58b966b75cbb5)

可以看出，

`p[i] = mx > i ? min(p[2 * id - i], mx - i) : 1;`

是Manacher的精髓，在朴素算法上加一行，即把O(n^2^)变成了O(n).

代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e7+5;
int n;
char str[maxn], m[maxn << 1];
int p[maxn] = { 0 };

int manacher(char * str)
{
	int len = 2;
	//m[len] = '\0';
	m[0] = '$', m[1] = '#';
	for (int i = 0; i < n; i++)
	{
		m[len++] = str[i];
		m[len++] = '#';
	}
	int ans = 1, id = 0, mx = 0;

	for (int i = 0; i < len; i++)
	{
		p[i] = mx > i ? min(p[2 * id - i], mx - i) : 1;
		while (m[i - p[i]] == m[i + p[i]]) p[i]++;
		if (i + p[i] > mx)
		{
			mx = i + p[i];
			id = i;
		}
		//cout << p[i];
		if (p[i]&1)
			ans = max(ans, p[i]);
	}
	//cout <<endl << m;
	//cout << endl;
	return ans - 1;
}

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n;
	cin >> str;
	cout << manacher(str);
}
```
