---
title: 数据结构与算法
date: 2019-09-03 12:59:19
tags:
- 课程笔记
category:
- 计算机科学
- 数据结构
mathjax: true
---

这是我大二上修的《数据结构与算法》的笔记。

## 1. 数据结构绪论

### 数据相关术语

数据：所有能被计算机识别的符号集合  
数据元素：是数据（结构）中的一个个体（一个人出生日期的年、月、日）  
数据项：是数据结构中讨论的最小单位（一个人的出生日期）
数据对象：具有相同性质的数据元素的集合（迷宫的每一个点）

### 数据结构相关术语

数据结构：带结构的数据元素的集合。全面的来说，$DS = (E, R, M)$，$E$、$R$、$M$ 分别为数据元素（Element）的集合、数据元素之间关系（Relation）的集合、存储（Memorizaion）数据元素单位的集合。  
逻辑结构：线性结构、树形结构、图形结构、集合结构。

存储结构：顺序存储、链式存储

操作：查找、插入、删除、遍历、排序……

### 数据类型相关术语

抽象数据类型（Abstract Data Type, ADT）：$ADT=(E,R,O)$。$O$ 指元素基本操作（Operation）的集合。

ADT 特点：抽象性（把定义和实现分开）、扩展性

### 算法相关术语

算法：解决某一特定问题的具体步骤的描述，是指令的有限序列。

算法是有穷的，通过有限步以后一定能得到输出；程序可以是无穷的，比如操作系统的核心进程，再启动完成后将驻留后台一直运行。

算法的五大基本性质：有穷性、确定性、可行性（能被分解为基本操作）、输入、输出。

算法设计的一般规则：正确性、可读性、健壮性（鲁棒性）、高效率和低存储量。  

## 线性结构及其查找和排序

### 线性表相关术语

线性表下标从 1 开始。

头元素、尾元素；  
前驱、后继、（直接）前驱、（直接）后继；

### KMP （坑）

老师讲的 `next[j]` 指 `p[0...j-1]` s的（不包含自己）的 border 的长度。如：

p[j]|a|b|a|a|c|a|b|a|a
-|-|-|-|-|-|-|-|-|-
next[j]|-1|0|0|1|1|0|1|2|3

### 查找

一些概念：

* ASL：平均查找长度。
* 静态查找：只做查询
* 动态查找：查到了删/没查到就插

#### 顺序查找

网课的实现是在头插入所查找元素，然后从后往前查找。即带岗哨的顺序查找版本。这样的好处是 `if` 条件句能少一个条件。  

等概率下：$ASL=\frac{n+1}{2}$；  
不等概率下：可以把高概率的放在后面。

#### 折半查找

需要有序表，并且只使用与顺序存储结构。

11 个数，等概率下：$ASL_{成功} = \frac{1}{11}(1 \times 1 + 2 \times 2 + 4 \times 3 + 4 \times 4)  = 3$，  
$ASL_{失败} = \frac{1}{12}(4 \times 3 + 8 \times 4)  \approx 4$

$n>50$ 时，可认为 $ASL \approx log_2(n+1)-1$。

#### 索引查找

想一想字典的查找方法：有一个索引。

索引搜索的步骤：

1. 分析数据，建立索引

    (1) 对数据进行分块。须保证第 $R_k$ 块所有关键字 < $R_{k+1}$ 块所有关键字（块间有序）。

    (2) 然后建立索引线性表，每项存储了每块的首地址和最大关键字  
	（注意最后一块后面也要存一个结束的查找表结束的地址，方便判断查找失败）

2. 查找
    (1) 索引表的查找（顺序或二分）
    (2) 查找表的查找（顺序或二分）

$
\begin{split}
\qquad ASL &= L_b+L_s \\\\
&= \frac{1}{b}\sum_{j=1}^b j + \frac{1}{s}\sum_{i=1}^s i \\\\
&= \frac{1}{2}(\frac{n}{s}+s)+1
\end{split}
$

#### 哈希查找

哈希函数即是一个将任意一个东西映射到 $[0, n-1]$ 的整数区间上的一个函数。常用的映射规则有直接（对于整数）对 n 取模、（对于字符串）把字符串看做一个 26（或 32，加速乘法）进制的数，按转换为 10 进制的方法，转为数以后取模。

哈希查找即是把元素映射到 $[0, n]$ 后，把元素放在线性表对应下标的内存中，查找时，计算哈希函数，然后在对应内存的地方找。一般 $n$ 的选择是质数。

哈希函数是密码学相关的，所以这门课程没有讨论太多相关的内容，更多讨论的是哈希表解决冲突的方法。

定义装填因子为要存的元素个数/哈希表空间能存的元素个数。

$a = \frac {L.length()}{n}$

显然，装填因子小，冲突的可能性会变小。

做题时，给定 $a$，若计算的 $n$ 不是整数，应向上取整（保证 $a$ 变小）。

解决冲突的方法有：

1. 线性探测再散列（即存入数据时，如果发生冲突，则尝试将数据存入后 $d_1=1$ 个位子，如下标超出 n 则模 n。仍然冲突，则尝试存入原数据后 $d_2=2$ 个位子……直至数据被存下）
2. 平方探测再散列（${d_i} = {1^2, -1^2, 2^2, -2^2, ...}$）
3. 随机数探测再散列（${d_i} = {7, 14, 21,...}$）
4. 链地址法（在哈希表的每一个内存外接链表）

常用方法 1 和 4。也有双哈希（即选择两个模数，然后建立二维数组作为哈希表）等方法。

ASL 的计算需要计算每个数的查找次数（或冲突次数+1）。若查找失败，需要按 $d_i$ 一直找，直到该内存没有数据。

另外，删除数据时，需要注意，**不能将该格还原为初始状态（如标记为 `-1`）**，否则某些后面的冲突项也会被忽略。  
正确的是，进行特殊标记（如标记为 `-2`）。

### 排序

#### 排序的稳定性

如果排序过程中，相同的数字的相对顺序可能变化，则称这个排序是不稳定的。

如快排，对于序列 $(3, \underline{3}, 2)$，排序以后是 $(2, \underline{3}, 3)$，两个 3 的相对位置，因此快排是不稳定的。

#### 快速排序

快速排序思想就不说了，网上有很多。

空间的支出主要是递归的栈消耗，空间复杂度最好情况是 $O(logn)$ 的，最坏（若原数组基本有序）是 $O(n)$ 的。

时间复杂度最好情况是 $O(nlogn)$ 的，最坏（若原数组基本有序）是 $O(n^2)$ 的。

快速排序是不稳定的。

我写的~~超级丑的~~代码：

```c++
void quick_sort(vector<int>& Arr, int l, int r)
{
	if (r <= l + 1)
		return;
	int pivot = Arr[l];
	int i = l + 1, j = r - 1;
	while (i < j)
	{
		while (i < j && Arr[i] <= pivot)
			i++;
		while (i < j && Arr[j] >= pivot)
			j--;
		swap(Arr[i], Arr[j]);
	}
	if (Arr[i] <= pivot)
		i++;
	swap(Arr[i - 1ll], Arr[l]); //要让 pivot 即 Arr[l] 与一个小于他的数交换，于是需要判断 Arr[i] 是大于它还是小于它
	quick_sort(Arr, l, i - 1);
	quick_sort(Arr, i, r);
}
```

#### 归并排序（坑）

归并排序是先分解、递归，再进行排序、合并。

归并排序分为 二路归并排序，和多路（k 路）归并排序。

空间主要消耗在新建的数组，复杂度是 $O(n)$ 的。 

时间复杂度是 $O(nlogn)$ 的。

归并排序是稳定的。



## 递归与分治

### 分治算法的时间复杂度

戴波的书是参考《算法导论》写的，该节见另一篇[博客](/计算机科学/Design-and-Analysis-of-Algorithms/#分治算法)。

