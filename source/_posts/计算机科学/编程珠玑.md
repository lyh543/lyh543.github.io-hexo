---
title: 《编程珠玑》笔记
date: 2019-08-18 22:02:19
tags:
- 读书笔记
category:
- 计算机科学
mathjax: true
---

编程珠玑每一章讲了编程、开发的不同的方面。  
第一章讲如何准确、正确的定义问题。  
第二章讲算法设计（灵光一现，啊哈！算法）。  
第三章提到数据结构和编程的关系（欸有点面向对象的感觉）。  
第四章运用循环不变式来证明程序的正确性。  
第五章运用脚手架、断言调试程序。

## 将一个字符串 $S$ 的后 i 位移到前 i 位

如当 i = 3，$S = abcdefg$，则要求 $S^R = efgabcd$。

该问题出现在《编程珠玑》第二章。时间复杂度要求为 $O(n)$，空间复杂度要求为几十字节，并且算法尽量简洁。

### 一个方法

可以尝试以下方法：

> 将 `x[0]` 移动到临时变量 `t`，把 `x[i]` 移动到 `x[0]`，将 `x[2*i]` 移动到 `x[i]`，以此类推……直至取回 `x[0]`。  
> 若按该法没有移动所有元素，则对 `x[1]`、`x[2]`……`x[i-1]` 进行同样操作。

上述算法较好的完成了时空复杂度，但是不够简洁。

### 更简洁的方法：基本操作的威力

更简洁的办法是先实现一个 `reverse()` 函数，用于翻转一个字符串（如把 `qwerty` 变为 `(qwerty)^R` = `ytrewq`），时间复杂度为 $O(n)$，复杂度为几个字节。  
设 $S$ 串前 i 位为 $T_1$，后 (n-i) 位为 $T_0$。  
注意到 ${(T_1^R T_0^R)}^R = T_0 T_1$，即可以调用三次 `reverse()` 函数实现该问题：

```c++
reverse(0,i-1);
reverse(i,n-1);
reverse(0,n-1);
```

该算法简洁，而且不容易出错。

## 格式信函编程

出现在3.2。

要写这种的话，不如手写一个把模板转为实例的函数，方便维护。

模板：

```
Welcome back, $1!
We hope that you and all the members
of the $0 family are constantly
reminding your neighbors there
on $5 to shop with us.
As usual, we will ship your order to
    $3 $1 $2. $0
    $4 $5
    $6, $7 $8
```

解释器（伪代码）：

```
read fields from database
loop from start to end of schema
    c = next character in schema
    if c ! ='$'
        printchar c
    else
        c = next character in schema
        case c of '$':
            printchar '$'
        '0' - '9':
            printstring field[c]
        default:
            error("bad schema")
```

有点像 C 的风格。在这种情形下，C++ 的 `cout` 风格也不一定好。

## “更一般性的问题也许更容易解决”

第三章 3.6。

> 对于程序设计来说，这意味直接编写 23 种情况的问题很困难；**而编写一个处理 n 种情况的通用程序，再令 n = 23 来得到最终结果，却相对要容易一些**。  —— Polya: *How to solve it*

## 咖啡罐问题

David Gries 在其 *Science of Programming* 中将下面的问题称为“咖啡罐问题”。  
> 给定一个盛有一些黑色豆子和一些白色豆子的咖啡罐以及一大堆“额外”的黑色豆子，重复下面的过程，直至罐中仅剩一颗豆子为止：  
> 从罐中随机选取两颗豆子，如果颜色相同，就将它们都扔掉并且放入一个额外的黑色豆子；如果颜色不同，就将白色的豆子放回罐中，而将黑色的豆子扔掉。 证明该过程会终止。最后留在罐中的豆子颜色与最初罐中白色豆子和黑色豆子的数量有何函数关系？

这个问题看起来很有意思。  
步骤会结束的证明是每次操作以后，罐子里总会减少一颗豆子；  
而对于最后剩余的豆子的颜色，可以关注到每次操作会拿走 0 到 2 颗白豆子，没有改变白豆子数量的奇偶性，因此最后剩白豆子的充要条件是罐子里原有奇数颗白豆子。

## 用循环不变式证明程序的正确性

出现在第四章。

> 程序验证的基本技术：精确定义不变式并在编写每一行代码时随时保持不变式的成立。

如二分搜索中， `t` 总在 `[l, r]` 中。

> 证明二分搜索的正确性的方法分为三个部分：  
> 1. **初始化**。循环初次执行的时候不变式为真。
> 2. **保持**。如果在某次迭代开始的时候以及循环执行的时候，不变式都为真，那么循环体执行完后，不变式仍为真。
> 3. **终止**。即循环一定能停止。

话说 1 和 2 就是数学归纳法~~你看隔壁叔叔，都二十岁了还在打数理基础~~。证明了 1 和 2，我们就能证明，如果循环能够停止，那么其结果一定是正确的。因此我们还需要证明 3。

对于二分搜索算法，初始化和保持只要按照流程分类讨论就不难。停机的证明是停止条件是 `[l, r]` 内没有元素，而每次循环以后，范围必定减小至少 1。

## 断言

出现在第四、五章。

上面提到的循环不变式也是一种断言。

> 断言在程序维护过程中至关重要：当你拿到一段你从未见过而且多年来也没有其他人见过的代码时，有关该程序状态的断言对于理解程序时很有帮助的。

而断言这种东西，在 C 语言还真的有：assert。关于该语法，放到[另一篇博客](/C++/C++语法/assert/)。

总之工程开发要多用。

## 程序调试

在第五章。

调试不仅可以验证程序的正确性，还能验证其理论时间复杂度。

附一份我写的二分实现的 `lower_bound()` 函数，及用 `assert` 验证其正确性的[代码](./my_lower_bound_test_correctness.cpp)，以及验证其时间复杂度的[代码](./my_lower_bound_test_time_complexity.cpp)。但是时间复杂度的验证貌似不稳定。

## 粗略估算

出自于第七章。也是我认为非常难的一章，因为涉及到大量的**“常识”**。  
下面就列举一下本书中出现过的应该掌握的常识。

### 换算法则

#### 1. 72法则

> 如果增长率为 $x\\%$，那么在 $y$ 年后将会翻倍，其中 $xy = 72$。

即 $f(x)=(1+x\\%)^{\frac{72}{x}} \approx 2$。$1 \leq x \leq 15$ 时，误差在 $5\\%$ 内； $6 \leq x \leq 9$ 时，误差在 $1\\%$ 内。

$x$|1|2|3|4|5|6|7|8|9|10|15|20
-|-|-|-|-|-|-|-|-|-|-|-|-|
$(1+x\\%)^{\frac{72}{x}}$|2.0471|2.03989|2.03279|2.02582|2.01895|2.0122|2.00555|1.999|1.99256|1.98622|1.95591|1.92776

#### 2. “π 秒就是一个纳世纪”

一世纪有 $3.155 \times 10 ^ 7$ 秒。

#### 生活常识

常见的河流的流速：不到 2 英里（3.21 公里）/小时  

### Little 定理

> 系统中物体的平均数量等于物体离开系统的平均速率和每个物体在系统中停留的平均时间的乘积。

原定理没有提进入速率，但是如果物体离开和进入系统的总体出入流是平衡的，那么离开速率就是进入速率。

Little 定理简单的说来就是：

> 队列中物体的平均数量 = 进入速率 × 平均停留时间

#### 例1：排队

一个夜总会需要排队进入。这个夜总会能容纳 60 人，每个人在里面呆三小时，那么进入夜总会的速率是 20 人/小时。这样你就能从队伍前面有多少人来判断大概还有多少时间进去。

#### 例2：死亡率和平均寿命

由 Little 定理可知：

> 每年的死亡率 × 平均寿命 = 1

如死亡率为 1.4%，则平均寿命为 71 岁。

### 自己的电脑的运算速度

对于一个程序员，知道现在电脑的运算量也非常重要。我就花了一天的时间，测试了一下 C 语言中各种运算的时间。由于内容过长，另开[文章](/C++/C++语法/calculating_efficiency/)以阐述。

## 安全系数

出现自第七章。

在做出可靠性、可用性保证时，给出和我们的目标差十倍的结果；  
在估算规模、开销和时间进度时，应该给出 2-4 倍保守的结果。
