---
title: 动态规划 讲座
date: 2019.5.17
tags:
- DP
category:
- C++
- ACM
---

## DP是什么

DP：把一些反复搜索的东西记录下来

问题原则：

1. 每次决策不会对后面的决策造成影响（无后效性，网络流不满足）
2. 每个子问题答案只由对应部分决定，不会被其他部分影响（最优子结构）

DP步骤：

1. 表示子问题的状态（状态定义）
2. 归纳状态间的转移（状态转移，重点）
3. 边界状态需要单独赋值（边界条件、初始条件）

核心代码很短（甚至比暴力还短），但是思维过程较多。

## 经典模型

### 01背包

背包容量为v  
有n个物体  
每个物体有体积vol、价值val
往背包装入一些物品，使物品价值和更大。

贪心：贪不动

```c++
for(int i = 1; i <= n; i++)
    {
        for(int j = 0; j <= W; j++)
        {
            if(j < w[i])    dp[i][j]  = dp[i-1][j];
            else dp[i][j] =  max(dp[i-1][j], dp[i-1][j - w[i]] + v[i]);
        }
    }
```

需要遍历所有 weight 和 thing

边界条件 i==0 or j == 0
ans = max(dp)

### 过河卒

从棋盘左上角走到右下角，只能向右走或向下走，有些格子不能走（被马控制了），求有多少种走法。

## 序列型dp：最长上升子序列（LIS）

DP 好像有点麻烦，要么 O(n^2), 要么需要线段树、树状数组维护

利用辅助数组
low[i] 表示长度为 i 的 LIS 的结尾元素（大概就是“最长上升子序列 LIS”）

## 区间型dp：石子归并

若 l 到 r 的石子被合并为一堆，则 l~r间的所有石子都被合并，一定存在 k ,最后一步是将 l~k 到 k+1~r 合并。k即是我们的决策。
再用前缀和做，复杂度 O(n^3)

要是石子形成一个环，在每个地方切一次，复杂度 O(n^4)能过。**xjtql**

## 树形dp：没有上司的舞会

在树形结构上，选取一些点，让这些点不两两相邻，并且权值和最大。

将树退化为链：

```c++
dp[i][1] = dp[i-1][0] + v[i];
dp[i][0] = max(dp[i-1][1], dp[i-1][0]);
```

回到树

```c++
// for each node
dfs();
dp[i][1] = sigma(dp[j][0])
dp[i][0] = sigma(max(dp[j][0], dp[j][1]))
//dp[i][0] 表示不选节点i的儿子的最大值
//dp[i][1] 表示选节点i的儿子的最大值
```

## 状压dp

一些格子可以放点，不能产生相邻点，求一共有多少种方法。m, n<=12

每一行状态和前2+行无关

每个行可以用数的二进制表示

然后怎么做呢？？？

## dp优化

### 奶牛

 选取权值和最大的数组，但是连续最多选两个

```
f[i]=max(f[j], sum(j,i))
```

单调队列优化dp

我没了

### 矩阵快速幂

就是数字快速幂外加定义一个矩阵乘法（复杂度 $O(k^3*log(n))$，但是 $k$ 是常数）
