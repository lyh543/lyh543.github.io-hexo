---
title: 求逆元
date: 2019-8-19
tags:
- 数论
category:
- C++
- ACM
mathjax: true
---

const int mod=97;`

## 若mod是质数

可用费马小定理+快速幂

```c++
int quickpow(int base, int pow)
{
    int ans = 1;
    while (pow)
    {
        if (pow & 1)
            ans = ans * base % mod;
        pow >>= 1;
        base = base * base % mod;
    }
    return ans;
}

int inv1(int a)
{
    return quickpow(a,mod-2);
}
```

## 若求 1~n 的逆元

可以用递推式

$$ i^{-1} = (p - \lfloor \frac{p}{i} \rfloor) \times (p \\% i) ^ {-1} \space \\% p $$
$$ i ^ {-1} = \frac{1}{i} = \frac{p-a}{b} \space \\% p $$
$$ \Big( p = ai + b, \lfloor \frac{p}{i} \rfloor = a, p \\% i = b \Big) $$

其中 inv[1] = 1;

```c++
int inv[mod] = {0,1};
int init_inv2()
{
    for(int i = 2; i < mod; i++)
        inv[i]=(mod-mod/i)*(inv[mod % i])%mod;
}
```

## 扩展欧几里得定理

裴蜀定理告诉了我们，ax+by=d存在整数解当且仅当 `gcd(a,b)∣d`
`ax+by=gcd(a,b)`可以递归为`ax'+by'=gcd(b,a%b)`
其中`x=y', y=x'-[a/b]*y`
当`b==0`时，令`x=1, y=0`即可递推至原来的x,y

若a,b互质，则`ax+by=gcd(a,b)=1`，x即是a的逆元（mod b）

```c++
int exgcd(int a, int b, int &x ,int &y)
{
    if (b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    int ans = exgcd(b,a%b,x,y);
    int temp = x;
    x = y;
    y = temp - a / b * x;
    return ans;
}
int inv3(int a)
{
    int x, y;
    exgcd(a,mod,x,y);
    return (x+mod)%mod;
}
```

## 若a,b不互质

甚至简单不能使用逆元，但是
若`b|a`, 有`a / b mod p == a mod(b*p) / b`
就可以快乐的用逆元啦。
