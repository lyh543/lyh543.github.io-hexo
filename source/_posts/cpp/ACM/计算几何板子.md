---
title: 计算几何板子
date: 2019-7-19
tags:
- 计算几何
- 资源
category:
- C++
- ACM
mathjax: true
---

> 参考链接：https://www.cnblogs.com/Eterna-King/p/10542881.html

计算几何，就是把高中的向量知识、解析几何知识进行编程化，然后用它来解决程序问题。本质还是考思维能力，但是没有板子也是万万不能的。下面就放一份潇神的板子。当然，有空也可以自己写一个。

```c++
//------------------------------点与直线部分-----------------------------
const double pi = acos(-1.0);
const double eps = 1e-10;
inline int Dcmp(double x) {
    if (fabs(x) < eps)return 0;
    else return x > 0 ? 1 : -1;
}
struct point {
    friend istream& operator >>(istream& in, point& rhs) {
        in >> rhs.x >> rhs.y;
        return in;
    }
    friend ostream& operator <<(ostream& os, const point& rhs) {
        os << rhs.x << ' ' << rhs.y;
        return os;
    }
    bool operator == (const point& rhs)const {
        return Dcmp(x - rhs.x) == 0 && Dcmp(y - rhs.y) == 0;
    }
    bool operator < (const point& rhs)const {
        return x < rhs.x || (x == rhs.x && y < rhs.y);
    }
    bool operator >(const point& rhs)const {
        return rhs < *this;
    }
    point operator + (const point& p)const {
        return point(x + p.x, y + p.y);
    }
    point operator * (double p)const {
        return point(x * p, y * p);
    }
    //点乘
    double dot(const point& p) const {
        return x * p.x + y * p.y;
    }
    //叉乘
    double det(const point& p)const {
        return x * p.y - y * p.x;
    }
    double x, y;
};
struct line {
    friend istream& operator >>(istream& in, line& rhs) {
        in >> rhs.p >> rhs.v;
        return in;
    }
    friend ostream& operator <<(ostream& os, const line& rhs) {
        os << rhs.p << ' ' << rhs.v;
        return os;
    }
    bool operator < (const line& rhs)const {
        if (Dcmp(ang - rhs.ang))return ang < rhs.ang;
        else return Dcmp(v.det(rhs.v)) == -1;
    }
    point Get_Point(double t)const {
        return p + v * t;
    }
    bool IsParallel(const line& rhs)const { return Dcmp(v.det(rhs.v)) == 0; }
    point p, v;
    double ang;
    line() {}
    line(point _p, point _v) :p(_p), v(_v) { ang = atan2(_v.y, _v.x); }
};
//不想写scanf
inline point read_point() {
    double x, y;
    scanf("%lf %lf", &x, &y);
    return point(x, y);
}
//向量长度
inline double length(const point& a) { return sqrt(a.dot(a)); }
//两点之间长度的平方
inline double Dist(const point& a, const point& b) { return (a - b).dot(a - b); }
//两向量的夹角
inline double Angle(const point& a, const point& b) { return acos(a.dot(b) / (length(a) * length(b))); }
//三点无向面积公式
inline double Area2(const point& a, const point& b, const point& c) { return fabs((b - a).det(c - a)) / 2; }
//判断p q两点是否在线段ab的同侧
inline bool SameSide(const point& a, const point& b, const point& p, const point& q) {
    point ab = b - a, ac = p - a, ap = q - a;
    double res = ab.det(ac) * ab.det(ap);
    return Dcmp(res) >= 0;
}
//判断点是否在三角形内
inline bool InTriangle(const point& a, const point& b, const point& c, const point& p) { return SameSide(a, b, c, p) && SameSide(b, c, a, p) && SameSide(c, a, b, p); }
//逆时针旋转向量
inline point Rotate(const point& rhs, double rad) { return point(rhs.x * cos(rad) - rhs.y *sin(rad), rhs.x * sin(rad) + rhs.y * cos(rad)); }
//求向量单位法向量
inline point Normal(const point& rhs) {
    if (Dcmp(rhs.x) == 0 && Dcmp(rhs.y) == 0)return point(0.0, 0.0);
    double len = length(rhs);
    return point(-rhs.y / len, rhs.x / len);
}
//求单位向量
inline point Unit_vector(const point& rhs) {
    double len = length(rhs);
    return point(rhs.x / len, rhs.y / len);
}
//判断q点是否在线段p1, p1上
inline bool On_seg(const point& p1, const point& p2, const point& q) { return Dcmp((p1 - q).det(p2 - q)) == 0 && Dcmp((p1 - q).dot(p2 - q)) < 0; }
//判断p是否在直线左边
inline bool On_Left(const line& L, const point& p) { return L.v.det(p - L.p) > 0; }
//通过4点坐标求两直线交点
inline point Intersection_point(const point& p1, const point& p2, const point& q1, const point& q2) {
    return p1 + (p2 - p1) * ((q2 - q1).det(q1 - p1) / (q2 - q1).det(p2 - p1));
}
//通过直线上一点及其方向向量求交点
inline point Intersection_line(const line& L1, const line& L2) {
    point u = L1.p - L2.p;
    double t = L2.v.det(u) / L1.v.det(L2.v);
    return L1.p + L1.v * t;
}
//判断两线段是否规范相交
inline bool SegmentProperIntersection(const point& a1, const point& a2, const point& b1, const point& b2) {
    double c1 = (a2 - a1).det(b1 - a1), c2 = (a2 - a1).det(b2 - a1), c3 = (b2 - b1).det(a1 - b1), c4 = (b2 - b1).det(a2 - b1);
    return Dcmp(c1) * Dcmp(c2) < 0 && Dcmp(c3) * Dcmp(c4) < 0;
}
//判断两线段是否相交，判断所有情况
inline bool SegmentIntersection(const point& a1, const point& a2, const point& b1, const point& b2) {
    if (Dcmp((a2 - a1).det(b2 - b1)) == 0)return On_seg(a1, a2, b1) || On_seg(a1, a2, b2) || On_seg(b1, b2, a1) || On_seg(b2, b2, a2);
    double c1 = (a2 - a1).det(b1 - a1), c2 = (a2 - a1).det(b2 - a1), c3 = (b2 - b1).det(a1 - b1), c4 = (b2 - b1).det(a2 - b1);
    return Dcmp(c1) * Dcmp(c2) < 0 && Dcmp(c3) * Dcmp(c4) < 0;
}
//求点p到直线ab的垂直距离
inline double DistanceToLine(const point& p, const point& a, const point& b) { return 2 * Area2(p, a, b) / length(a - b); }
//求点p到线段ab的距离
inline double DistanceToSegment(const point& p, const point& a, const point& b) {
    if (a == b)return length(p - a);
    point v1 = b - a, v2 = p - a, v3 = p - b;
    if (Dcmp(v1.dot(v2) < 0))return length(v2);
    else if (Dcmp(v1.dot(v3) > 0))return length(v3);
    else return DistanceToLine(p, a, b);
}
//求点p在直线ab上的投影点
inline point GetLineProjection(const point& p, const point& a, const point& b) {
    point v = b - a;
    return a + v * (v.dot(p - a) / v.dot(v));
}
//计算凸多边形面积
double ConvexPolygonArea(point* p, int n) {
    double res = 0;
    for (int i = 1; i < n - 1; ++i)res += Area2(p[0], p[i], p[i + 1]);
    return res;
}
//计算任意多边形面积公式
double PolygonArea(point* p, int n) {
    double res = 0;
    for (int i = 1; i < n - 1; ++i)res += (p[i] - p[0]).det(p[i + 1] - p[0]);
    return res / 2;
}
//判断点是否在多边形内
int isPointinPolygon(const point& p, vector<point>& v) {
    int cnt = 0, n = v.size();
    for (int i = 0; i < n; ++i) {
        if (On_seg(v[i], v[(i + 1) % n], p))return -1;
        int k = Dcmp((v[(i + 1) % n] - v[i]).det(p - v[i]));
        int d1 = Dcmp(v[i].y - p.y), d2 = Dcmp(v[(i + 1) % n].y - p.y);
        if (k > 0 && d1 <= 0 && d2 > 0)++cnt;
        if (k < 0 && d2 <= 0 && d1 > 0)--cnt;
    }
    if (cnt)return 1;//内部
    else return 0;//外部
}
vector<point> v;
//构造凸包
inline void Get_convex_hall(point* arr, int n) {
    v.clear();
    v.resize(n << 1);
    sort(arr + 1, arr + 1 + n);
    int cnt = 0;
    for (int i = 1; i <= n; ++i) {
        while (cnt > 1 && (v[cnt - 1] - v[cnt - 2]).det(arr[i] - v[cnt - 1]) <= 0)--cnt;
        v[cnt++] = arr[i];
    }
    for (int i = n - 1, t = cnt; i > 0; --i) {
        while (cnt > t && (v[cnt - 1] - v[cnt - 2]).det(arr[i] - v[cnt - 1]) <= 0)--cnt;
        v[cnt++] = arr[i];
    }
    v.resize(cnt - 1);
}
//旋转卡壳
double Rotate_Calipers() {
    double res = 0.0;
    int n = v.size();
    v.push_back(v[0]);
    int now = 1;
    for (int i = 0; i < n; ++i) {
        while ((v[now] - v[i + 1]).det(v[i] - v[i + 1]) < (v[now + 1] - v[i + 1]).det(v[i] - v[i + 1]))now = (now + 1) % n;
        res = max(res, max(Dist(v[now], v[i]), Dist(v[now + 1], v[i + 1])));
    }
    v.pop_back();
    return res;
}
//求半平面交
bool HalfPlaneIntersection(line* arr, int n, vector<point>& v) {
    deque<line> qLine;
    deque<point> qPoint;
    sort(arr + 1, arr + 1 + n);
    qLine.push_back(arr[1]);
    for (int i = 2; i <= n; ++i) {
        if (Dcmp(arr[i].ang - arr[i - 1].ang)) {
            if (qLine.size() > 1 && (qLine[0].IsParallel(qLine[1]) || qLine[qLine.size() - 1].IsParallel(qLine[qLine.size() - 2])))return false;
            while (qLine.size() > 1 && !On_Left(arr[i], qPoint[qPoint.size() - 1]))qPoint.pop_back(), qLine.pop_back();
            while (qLine.size() > 1 && !On_Left(arr[i], qPoint[0]))qPoint.pop_front(), qLine.pop_front();
            qLine.push_back(arr[i]);
            if (qLine.size() > 1)qPoint.push_back(Intersection_line(qLine[qLine.size() - 1], qLine[qLine.size() - 2]));
        }
    }
    while (qLine.size() > 1 && !On_Left(qLine[0], qPoint[qPoint.size() - 1]))qLine.pop_back(), qPoint.pop_back();
    while (qLine.size() > 1 && !On_Left(qLine[qLine.size() - 1], qPoint[0]))qLine.pop_front(), qPoint.pop_front();
    if (qPoint.size() < 2)return false;
    qPoint.push_back(Intersection_line(qLine[0], qLine[qLine.size() - 1]));
    for (int i = 0; i < qPoint.size(); ++i)v.push_back(qPoint[i]);
    return true;
}
//------------------------------点与直线部分-----------------------------

//------------------------------圆与球部分-------------------------------
struct circle {
    friend istream& operator >>(istream& in, circle& rhs) {
        in >> rhs.c >> rhs.r;
        return in;
    }
    friend ostream& operator <<(ostream& os, const circle& rhs) {
        os << rhs.c << " " << rhs.r;
        return os;
    }
    point c;
    double r;
    circle() {}
    circle(point _c, double _r) :c(_c), r(_r) {}
    //通过圆心角求圆上点
    point Get_point(double a)const { return point(c.x + r * cos(a), c.y + r * sin(a)); }
};
//求极角
inline double polar_angle(const point& rhs) { return atan2(rhs.y, rhs.x); }
//将角度转换为弧度
inline double torad(double deg) { return deg / 180. * pi; }
//解方程求直线与圆的交点
int GetLineCircleIntersection(const line& L, const circle& C, double& t1, double& t2, vector<point>& v) {
    double a = L.v.x, b = L.p.x - C.c.x, c = L.v.y, d = L.p.y - C.c.y;
    double e = a * a + c * c, f = 2 * (a * b + c * d), g = b * b + d * d - C.r * C.r;
    double delta = f * f - 4 * e * g;
    if (Dcmp(delta) < 0)return 0;
    if (Dcmp(delta) == 0) {
        t1 = t2 = -f / (2 * e);
        v.push_back(L.Get_Point(t1));
        return 1;
    }
    t1 = (-f - sqrt(delta)) / (2 * e);
    t2 = (-f + sqrt(delta)) / (2 * e);
    v.push_back(L.Get_Point(t1));
    v.push_back(L.Get_Point(t2));
    return 2;
}
//勾股定理求直线与圆的交点
int GetLineCircleIntersection(const point& A, const point& B, const circle&C, double& L, vector<point>& v) {
    double d = DistanceToLine(C.c, A, B);
    if (Dcmp(C.r - d) < 0)return 0;
    point p = GetLineProjection(C.c, A, B);
    double len = sqrt(C.r * C.r - d * d);
    if (Dcmp(len) == 0) {
        L = 0;
        v.push_back(p);
        return 1;
    }
    point unit = Unit_vector(B - A);
    L = len;
    v.push_back(p - unit * len);
    v.push_back(p + unit * len);
    return 2;
}
//求两圆交点
int GetCircleCircleIntersection(const circle& C1, const circle& C2, vector<point>& v) {
    double d = length(C1.c - C2.c);
    if (Dcmp(d) == 0) {
        if (Dcmp(C1.r - C2.r) == 0)return -1;//两圆重合
        return 0;
    }
    if (Dcmp(C1.r + C2.r - d) < 0 || Dcmp(fabs(C1.r - C1.r) - d) > 0)return 0;
    double a = polar_angle(C2.c - C1.c);
    double da = acos((C1.r * C1.r + d * d - C2.r * C2.r) / (2 * C1.r * d));
    point p1 = C1.Get_point(a - da), p2 = C1.Get_point(a + da);
    v.push_back(p1);
    if (p1 == p2)return 1;
    v.push_back(p2);
    return 2;
}
//求点到圆的切线
int GetTangents(const point& p, const circle& c, vector<point>& v) {
    point u = c.c - p;
    double dist = length(u);
    if (dist < c.r)return 0;
    else if (Dcmp(dist - c.r) == 0) {
        v.push_back(Rotate(u, pi / 2));
        return 1;
    }
    else {
        double ang = asin(c.r / dist);
        v.push_back(Rotate(u, -ang));
        v.push_back(Rotate(u, +ang));
        return 2;
    }
}
//求两圆的切线，返回切线个数
int GetTangents(circle A, circle B, vector<point>& a, vector<point>& b) {
    if (Dcmp(A.r - B.r) < 0) {
        swap(A, B);
        swap(a, b);
    }
    double d2 = Dist(A.c, B.c), rdiff = A.r - B.r, rsum = A.r + B.r;
    if (Dcmp(d2 - rdiff * rdiff) == -1)return 0;//内含
    double base = atan2(B.c.y - A.c.y, B.c.x - A.c.x);
    if (Dcmp(d2) == 0 && Dcmp(A.r - B.r) == 0)return -1;
    if (Dcmp(d2 - rdiff * rdiff) == 0) {
        a.push_back(A.Get_point(base));
        b.push_back(B.Get_point(base));
        return 1;
    }//内切
    double ang = acos((A.r - B.r) / sqrt(d2));
    a.push_back(A.Get_point(base + ang)), a.push_back(A.Get_point(base - ang));
    b.push_back(B.Get_point(base + ang)), b.push_back(B.Get_point(base - ang));
    if (Dcmp(d2 - rsum * rsum) == 0) {
        a.push_back(A.Get_point(base));
        b.push_back(B.Get_point(pi + base));
    }
    else if (Dcmp(d2 - rsum * rsum) > 0) {
        ang = acos((A.r + B.r) / sqrt(d2));
        a.push_back(A.Get_point(base + ang)), a.push_back(A.Get_point(base - ang));
        b.push_back(B.Get_point(pi + base + ang)), b.push_back(B.Get_point(pi + base - ang));
    }
    return (int)a.size();
}
//求三角形外接圆
circle CircumscribedCircle(const point& a, const point& b, const point& c) {
    double Bx = b.x - a.x, By = b.y - a.y, Cx = c.x - a.x, Cy = c.y - a.y;
    double D = 2 * (Bx * Cy - Cx * By);
    double cx = (Cy * (Bx * Bx + By * By) - By *(Cx * Cx + Cy * Cy)) / D + a.x;
    double cy = (Bx * (Cx * Cx + Cy * Cy) - Cx *(Bx * Bx + By * By)) / D + a.y;
    point p = point(cx, cy);
    return circle(p, length(a - p));
}
//求三角形内接圆
circle InscribedCircle(const point& a, const point& b, const point& c) {
    double lena = length(b - c), lenb = length(c - a), lenc = length(a - b);
    point p = (a * lena + b * lenb + c * lenc) / (lena + lenb + lenc);
    return circle(p, DistanceToLine(p, a, b));
}
//------------------------------圆与球部分-------------------------------
```
