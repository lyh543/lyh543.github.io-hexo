---
title: 数据结构与算法
date: 2019-09-03 12:59:19
tags:
- 课程笔记
category:
- 计算机科学
- 数据结构
mathjax: true
---

这是我大二上修的《数据结构与算法》的笔记。

## 1. 数据结构绪论

### 数据相关术语

数据：所有能被计算机识别的符号集合  
数据元素：是数据（结构）中的一个个体（一个人出生日期的年、月、日）  
数据项：是数据结构中讨论的最小单位（一个人的出生日期）
数据对象：具有相同性质的数据元素的集合（迷宫的每一个点）

### 数据结构相关术语

数据结构：带结构的数据元素的集合。全面的来说，$DS = (E, R, M)$，$E$、$R$、$M$ 分别为数据元素（Element）的集合、数据元素之间关系（Relation）的集合、存储（Memorizaion）数据元素单位的集合。  
逻辑结构：线性结构、树形结构、图形结构、集合结构。

存储结构：顺序存储、链式存储

操作：查找、插入、删除、遍历、排序……

### 数据类型相关术语

抽象数据类型（Abstract Data Type, ADT）：$ADT=(E,R,O)$。$O$ 指元素基本操作（Operation）的集合。

ADT 特点：抽象性（把定义和实现分开）、扩展性

### 算法相关术语

算法：解决某一特定问题的具体步骤的描述，是指令的有限序列。

算法是有穷的，通过有限步以后一定能得到输出；程序可以是无穷的，比如操作系统的核心进程，再启动完成后将驻留后台一直运行。

算法的五大基本性质：有穷性、确定性、可行性（能被分解为基本操作）、输入、输出。

算法设计的一般规则：正确性、可读性、健壮性（鲁棒性）、高效率和低存储量。  

## 线性结构及其查找和排序

### 线性表相关术语

线性表下标从 1 开始。

头元素、尾元素；  
前驱、后继、（直接）前驱、（直接）后继；

### KMP （坑）

老师讲的 `next[j]` 指 `p[0...j-1]` s的（不包含自己）的 border 的长度。如：

p[j]|a|b|a|a|c|a|b|a|a
-|-|-|-|-|-|-|-|-|-
next[j]|-1|0|0|1|1|0|1|2|3

### 查找

一些概念：

* ASL：平均查找长度。
* 静态查找：只做查询
* 动态查找：查到了删/没查到就插

#### 顺序查找

网课的实现是在头插入所查找元素，然后从后往前查找。即带岗哨的顺序查找版本。这样的好处是 `if` 条件句能少一个条件。  

等概率下：$ASL=\frac{n+1}{2}$；  
不等概率下：可以把高概率的放在后面。

#### 折半查找

需要有序表，并且只使用与顺序存储结构。

11 个数，等概率下：$ASL_{成功} = \frac{1}{11}(1 \times 1 + 2 \times 2 + 4 \times 3 + 4 \times 4)  = 3$，  
$ASL_{失败} = \frac{1}{12}(4 \times 3 + 8 \times 4)  \approx 4$

$n>50$ 时，可认为 $ASL \approx log_2(n+1)-1$。

#### 索引查找

想一想字典的查找方法：有一个索引。

索引搜索的步骤：

1. 分析数据，建立索引

    (1) 对数据进行分块。须保证第 $R_k$ 块所有关键字 < $R_{k+1}$ 块所有关键字（块间有序）。

    (2) 然后建立索引线性表，每项存储了每块的首地址和最大关键字  
	（注意最后一块后面也要存一个结束的查找表结束的地址，方便判断查找失败）

2. 查找
    (1) 索引表的查找（顺序或二分）
    (2) 查找表的查找（顺序或二分）

$
\begin{split}
\qquad ASL &= L_b+L_s \\\\
&= \frac{1}{b}\sum_{j=1}^b j + \frac{1}{s}\sum_{i=1}^s i \\\\
&= \frac{1}{2}(\frac{n}{s}+s)+1
\end{split}
$

#### 哈希查找

哈希函数即是一个将任意一个东西映射到 $[0, n-1]$ 的整数区间上的一个函数。常用的映射规则有直接（对于整数）对 n 取模、（对于字符串）把字符串看做一个 26（或 32，加速乘法）进制的数，按转换为 10 进制的方法，转为数以后取模。

哈希查找即是把元素映射到 $[0, n]$ 后，把元素放在线性表对应下标的内存中，查找时，计算哈希函数，然后在对应内存的地方找。一般 $n$ 的选择是质数。

哈希函数是密码学相关的，所以这门课程没有讨论太多相关的内容，更多讨论的是哈希表解决冲突的方法。

定义装填因子为要存的元素个数/哈希表空间能存的元素个数。

$a = \frac {L.length()}{n}$

显然，装填因子小，冲突的可能性会变小。

做题时，给定 $a$，若计算的 $n$ 不是整数，应向上取整（保证 $a$ 变小）。

解决冲突的方法有：

1. 线性探测再散列（即存入数据时，如果发生冲突，则尝试将数据存入后 $d_1=1$ 个位子，如下标超出 n 则模 n。仍然冲突，则尝试存入原数据后 $d_2=2$ 个位子……直至数据被存下）
2. 平方探测再散列（${d_i} = {1^2, -1^2, 2^2, -2^2, ...}$）
3. 随机数探测再散列（${d_i} = {7, 14, 21,...}$）
4. 链地址法（在哈希表的每一个内存外接链表）

常用方法 1 和 4。也有双哈希（即选择两个模数，然后建立两个一位数组作为哈希表，查找时若两表都查到了，就认为查找成功）等方法。

ASL 的计算需要计算每个数的查找次数（或冲突次数+1）。若查找失败，需要按 $d_i$ 一直找，直到该内存没有数据。

另外，删除数据时，需要注意，**不能将该格还原为初始状态（如标记为 `-1`）**，否则某些后面的冲突项也会被忽略。  
正确的是，进行特殊标记（如标记为 `-2`）。

### 排序

#### 排序的稳定性

如果排序过程中，相同的数字的相对顺序可能变化，则称这个排序是不稳定的。

如快排，对于序列 $(3, \underline{3}, 2)$，排序以后是 $(2, \underline{3}, 3)$，两个 3 的相对位置，因此快排是不稳定的。


稳定的排序有：简单插入、冒泡排序、归并排序

不稳定的排序有：希尔排序、简单选择、快速排序

#### 简单插入排序

就是第 $i$ 趟保证前 $i$ 个数之间有序；为此，每次把第 $i$ 个元素插入到前 $i-1$ 个元素之间（慢在插入的过程需要移位）。如下序列跑三趟的结果是：

**4** 2 1 3  
**2 4** 1 3  
**1 2 4** 3  
**1 2 3 4**

一般会使用第 0 位作为岗哨。

简单插入排序简单好写，并且在基本有序的表上表现很好：在有序表上只需要 $n-1$ 次比较和 0 次交换数据。交换数据的次数完全等于逆序对的个数。

#### 希尔排序

希尔排序（Shell Sort）是改进的简单插入排序。他将数据进行分组，然后进行排序，再把小组合为大组继续排序，以此类推。

如果把数据按分块的方式进行分组，对复杂度影响其实不大；有意思的是，如果是隔几个数分为一组（如123123123……），就会有神奇的效果：  
一趟排序完成以后，每组基本都是有序的，整体来看也是小的在前，大的在后，这样，每趟就是基本有序的插入排序了，复杂度接近 $O(n)$。平均复杂度就得到了降低。

然而，希尔排序的最坏复杂度可以为 $\Theta(n^2)$，如构造以下数列：

```
1 9 2 10 3 11 4 12 5 13 6 14 7 15 8 16
```

按间隔 $d_i=\\{8,4,2,1\\}$ 的话，前三趟做的都是无用功，最后一趟实际等同于简单插入排序，复杂度为 $\Theta(n^2)$。（实际上 $\\{8,2,4,1\\}$ 就是 Shell 本人提出的序列）

上述的原因是，增量间不互质，于是小的增量可能没有效果。

接下来，就是讨论希尔排序的增量序列（和哈希函数一样，想在一个核心上做文章，取得整体的复杂度的改善）。

##### 各种增量序列（了解）

此后，很多数学大牛都来提出了自己的序列。可参考英文[维基百科](https://en.wikipedia.org/wiki/Shellsort)。

希尔伯特（Hibbard）核心：增量序列 $h_k=2^k-1$。其最坏复杂度为 $\Theta(n^\frac{3}{2})$，平均复杂度为 $O(n^\frac{5}{4})$。

目前最新提出的有理论复杂度证明的是 1986 年提出的 Sedwick 序列，他的前几项为 $\\{1, 5, 19, 41, 109, ...\\}$。其递推式在很多国内网站都是错的，正确的如下：

${\begin{cases}9\left(2^{k}-2^{\frac {k}{2}}\right)+1 & k{\text{ even}} \\\\
8\cdot 2^{k}-6\cdot 2^{(k+1)/2}+1 & k{\text{ odd}}\end{cases}}$

按该数列进行希尔排序的最坏复杂度为 $O(n^\frac{3}{4}$，平均复杂度为 $O(n^\frac{7}{6})$。

这么看来希尔排序也不差，$O(n^\frac{7}{6})$ 的复杂度在小数据范围内基本可以和 $O(n \\ logn)$ 抗衡了（在 $n < 6 \times 10 ^ 8$ 下，$O(n^\frac{7}{6}) < O(n \\ log_2n)$）。

更新的几个研究成果都是给出了数列和递推式，但是没有给出理论最坏复杂度，大概是没有理论推进的，但是实测表现良好的方法吧。

#### 简单选择排序

就是扫一遍得到最小的数的下标，与 $a_0$ 交换；再扫一遍得到第二小的数的下标，与 $a_1$ 交换。与冒泡不同的是，他每趟只交换一次数据。

4 2 1 3  
**1** 2 4 3
**1 2** 4 3  
**1 2 3 4**

简单选择也可以选最大的数的下标。

#### 冒泡排序

最形象的算法之一。目的和简单选择一样：每次把没处理的序列的最小者放到最前面（或最大的放到最后面）。但是他的实现是多次交换。

注意，冒泡有两个优化：

1. 算法结束条件改为当前一趟没有交换任何数据。这样，对于有序表，进行 n-1 次比较即可完成排序。
2. 算法需要指定冒泡的最后一个位置 m `for(int m = n; m > 0; m--)`。但是并不是每个 m 的值都需要执行循环。要是这一趟的交换只交换到了 k(k<n)，下一次可令 `m=k-1;` 即跳过很多趟无用功。可以看到优化 2 是包含了优化 1 的。

简单选择排序和冒泡排序的每趟结果应该是一样的吧。

#### 快速排序

快速排序思想就不说了，网上有很多。

复杂度和枢纽的选择有关：选择 空间的支出主要是递归的栈消耗，空间复杂度最好情况是 $O(logn)$ 的，最坏（若原数组基本有序）是 $O(n)$ 的。  
时间复杂度最好情况是 $O(nlogn)$ 的，最坏是 $O(n^2)$ 的。

选择枢纽也非常重要，如果选择 a[0] 为枢纽，原数组基本有序，则是 $O(n^2)$ 的复杂度；  
可以使用 a[rand()] 为枢纽。但是 `rand()` 比较慢；  
还可以使用三者取中法：取`a[0]`、`a[n]`、`a[mid]` 的中间值作为枢纽。

快速排序是不稳定的。

我写的~~超级丑的~~代码：

```c++
void quick_sort(vector<int>& Arr, int l, int r)
{
	if (r <= l + 1)
		return;
	int pivot = Arr[l];
	int i = l + 1, j = r - 1;
	while (i < j)
	{
		while (i < j && Arr[i] <= pivot)
			i++;
		while (i < j && Arr[j] >= pivot)
			j--;
		swap(Arr[i], Arr[j]);
	}
	if (Arr[i] <= pivot)
		i++;
	swap(Arr[i - 1ll], Arr[l]); //要让 pivot 即 Arr[l] 与一个小于他的数交换，于是需要判断 Arr[i] 是大于它还是小于它
	quick_sort(Arr, l, i - 1);
	quick_sort(Arr, i, r);
}
```

有一个问题是枢纽 `pivot` 的选择：如果每次 `pivot` 取第一个，而数组原本有序，会进行 $O(n^2)$ 次比较和 0 次交换。

可以进行优化，枢纽取 `l`，`r`，`(l+r)/2` 位元素的中间大小者，可以优化约 5%。

#### 归并排序（坑）

归并排序是先分解、递归，再进行排序、合并。

归并排序分为 二路归并排序，和多路（k 路）归并排序。

空间主要消耗在新建的数组，复杂度是 $O(n)$ 的。 

时间复杂度是 $O(nlogn)$ 的。

归并排序是稳定的。

### 基数排序

基数排序就是多关键字（如 n 进制的第一位、第二位、第三位）排序的一个方法：定好按哪个进行排序，然后就只按照这个关键字排序。

基数排序分为高位优先排序和低位优先排序。

高位优先排序非常直观，先把所有元素按高位排序，然后再把相同高位的元素按次高位排序……以此类推。  
但是，高位优先排序的问题是麻烦：第一趟按把所有元素进行排序，第二趟按次高位排序时，需要确定高位相同的每一段的范围。

反而，按低位优先排序会有神奇的特效：

* 第一趟按最低位对所有数进行排序，  
* 第二趟按次低位对所有数进行排序，
* ...
* 最后一趟按最高位对所有数进行排序。

只要上述的每一趟排序使用的是**稳定**的排序方法，排完高位以后，相同高位的元素的低位也是有序的。

### 外部排序

以上学的几种方法都是直接在内存中进行操作的内部排序。  

而当数据量太大，无法全部从磁盘读入内存时，就只能把部分数据读入内存，多趟排序，这便是外部排序。

由于 I/O 的速度非常慢，外部排序中，我们主要考虑的是如何减少存储器的读写。  
**归并排序**就很适合外排序，因为他只需要访问被归并序列中的第一个元素。

外部排序的两个阶段：

* 预处理：根据内存大小读取文件记录入内存，用内排序算法排序形成有序片段；
* 归并排序（二路、多路、多阶段）：将有序片段归并为一个有序文件。

下面的例子是以磁带做存储器，因为它的读写过程比较形象。在实际应用中，可以把一个文件看作是一个磁带。

#### 预处理：置换算法

置换算法能在只能容纳 p 个记录的内存内生成平均长度为 2p 的已排序片段。

事实上，只要第一个元素被写入到输出磁带上，他用的内存空间就可以给别的元素使用。当然，这样的前提是，输入磁带的下一个元素比刚输出的元素大。

可以使用优先队列实现这个置换算法+内排序过程。

算法中，如果输入的元素小于等于刚输出的元素，则将其加入优先队列；如果大于刚输出的元素，就可以把它放进优先队列的空余位置（刚空出来的位置）。  
反复执行这个过程直至优先队列大小为 0。此时，空余位置也满了，可以对这些数重新构建优先队列。

#### 归并排序：二路归并

1. 把 A1 的数据预处理得到的片段被轮流写到文件 B1 和 B2 上。
2. 然后每次在 B1，B2 磁带上各取一个有序片段，进行二路归并，第一次写到 A1，第二次写到 A2，第三次写到 A1……
3. 下次交换 A1，A2 和 B1，B2 的地位，每次在 A1，A2 磁带上各取一个有序片段，进行二路归并，第一次写到 B1，第二次写到 B2，第三次写到 A3……
4. 重复步骤 2、3 直至只剩一个有序片段，即所有数据经过排序以后的数据。

#### 归并排序：多路归并

多路归并和二路归并的思想基本相同，只有一个细节地方需要处理：

在进行 k 路归并的时候，找到当前 k 路中的最小值，对于二路归并是 $O(1)$ 的复杂度；对于 k 路归并，暴力比较是 $O(k)$ 的复杂度，可以引进优先队列，则每次的复杂度为 $O(\log k)$。

运用多路归并虽然增加了一个树结构，但是复杂度竟然没有变化（二路归并为 $O(n\log_2n)$，k 路归并为 $O(n\log_kn\log_2k)=O(n\log_2n)$），还可以减少磁带读写次数。

#### 归并排序：多阶段归并

多阶段归并是多路归并的优化版本。

显然，k 路归并需要共 2k 条磁带，而多阶段归并可以仅用 k+1 条磁带实现 k 路归并。

过程有点复杂，虽然思想不是很复杂。就是要充分利用空出来的磁带，进行轮流合并。

如果一开始，每条磁带上的有序数列的数量取斐波那契数列时，多阶段归并会有非常好的效果。

（斐波那契数列在最优化中也有应用，~~真就从小学学到大学啊~~）

## 递归与分治

### 分治的适用情况

~~抄ppt~~

1. 该问题的规模缩小到一定的程度就可以容易地解决；
2. 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质；
3. 利用该问题分解出的子问题的解可以合并为该问题的解；
4. 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。

能否利用分治法完全取决于问题是否具有第三条特征，如果具备了前两条特征，而不具备第三条特征，则可以考虑贪心算法或动态规划。

而第四特征涉及到分治法的效率，如果各子问题是不独立的，则分治法要做许多不必要的工作：重复地解公共的子问题。此时虽然也可用分治法，但一般用动态规划较好。


### 分治算法的时间复杂度

戴波的书是参考《算法导论》写的，该节见另一篇[博客](/Computer-Science/Design-and-Analysis-of-Algorithms/#分治算法)。

## 树和二叉树

树中结点的度数是直接儿子的个数，不是图中度数的定义。

### 二叉树

$n_0=n_2+1$

* 存储结构：
- 顺序
- 链式  
	a. 二叉链式  
	b. 三叉链式（指加了一个父节点的指针））

* 遍历方法：
- 递归遍历（递归）
	a. 先序遍历
- 层次遍历（队列）
- 非递归遍历


* 二叉排序树

* 平衡二叉树

* 堆

* Huffman 编码

哈夫曼编码。构造方法：跑一遍优先队列。压缩率在 20%~90% 之间。

### 树

非二叉树没有中序遍历

森林与二叉树的转换：森林结点的儿子存储在二叉树的左节点，森林结点的兄弟存在二叉树的右节点。

计算表达式

* 后缀表达式天下第一
* 中缀表达式不唯一
* 前缀表达式的实现需要两个栈


## 后记

由于课程紧张，后期笔记就比较水了，这是中国大学 MOOC 的[学习链接](https://www.icourse163.org/course/0809uestc080-1002532005)。